import { ErrorCodes, SyncOtError } from './error'
import { JsonValue } from './json'
import { Result } from './result'

export type TypeName = string
export type OperationData = JsonValue
export type SnapshotData = JsonValue
export interface Operation {
    readonly type: TypeName
    readonly data: OperationData
}
export interface Snapshot {
    readonly type: TypeName
    readonly data: SnapshotData
}

/**
 * Defines an [OT](https://en.wikipedia.org/wiki/Operational_transformation) or
 * a [CRDT](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) data type.
 * At the minimum, each type has a name, an operation type, a snapshot type and a way to
 * apply an operation to a snapshot to produce a new snapshot.
 * OT types must additionally implement `transform` or `transformX`, so that their
 * operations could be transformed and applied in any order.
 * All other functions are optional and can be implemented to improve performance or
 * enable optional features like undo/redo.
 *
 * Data in SyncOT is represented by read-only `Snapshot`s.
 * `Snapshot` modifications are expressed as read-only `Operation`s.
 * New `Snapshot`s can be created from scratch or
 * generated by applying `Operation`s to existing `Snapshot`s.
 * New `Operation`s can be created from scratch or
 * generated in various ways from existing `Operation`s and `Snapshot`s.
 */
export interface Type {
    /**
     * The name of the type which should be in the following format "<namespace>/<type>".
     * It's recommended that the name is based on the user/organization and package name
     * from the type's source code repository in order to minimize the chance of conflicts.
     * The core types don't follow the naming convention as they live in the global namespace.
     */
    readonly name: TypeName

    /**
     * Returns a new snapshot, which is the result of applying `operation` to `snapshot`.
     *
     * @param snapshot A snapshot.
     * @param operation An operation to apply to the snapshot.
     */
    apply(snapshot: Snapshot, operation: Operation): Snapshot

    /**
     * Returns:
     * - at index 0: a new snapshot, which is the result of applying `operation` to `snapshot`.
     * - at index 1: a new operation, which reverts the effect of `operation`.
     *
     * This function may be implemented as an optimization, for example:
     * - apply and invert may be performed more efficiently together then separately.
     * - operations may not need to contain "invert" metadata, if they can extract it from the snapshot.
     *
     * `applyX` satisfies the following equasion:
     * `applyX(snapshot, operation) === [ apply(snapshot, operation), invert(operation) ]`
     *
     * @param snapshot A snapshot.
     * @param operation An operation to apply to the snapshot and to invert.
     */
    applyX?(snapshot: Snapshot, operation: Operation): [Snapshot, Operation]

    /**
     * Returns a new operation, which subsumes the behaviour of `operation`, but modified in such a way
     * that it can be applied to a snapshot modified by `anotherOperation.
     *
     * The purpose of transformation is to allow applying `operation` to a snapshot modified
     * by `anotherOperation`. This way each client can apply operations in any order and obtain an
     * identical final snapshot, as long as the operations are properly transformed.
     *
     * Although each client can apply operations in any order, SyncOT uses a central server which
     * defines a canonical total order of operations. The `priority` parameter indicates which operation
     * happened first in that cannonical total order.
     *
     * `transform` satisfies the following equasion:
     * `apply(apply(snapshot, operation1), transform(operation2, operation1, false)) ===
     *      apply(apply(snapshot, operation2), transform(operation1, operation2, true))`
     *
     * @param operation An operation which needs to be transformed, so that it can be
     *  applied to the snapshot modified by `anotherOperation.
     * @param anotherOperation An operation which has modified the snapshot to which
     *  `operation` needs to be applied.
     * @param priority If `true`, `operation` happened first in the total order of operations
     *  defined by the server, otherwise `anotherOperation` happended first.
     */
    transform?(
        operation: Operation,
        anotherOperation: Operation,
        priority: boolean
    ): Operation

    /**
     * Returns `operation1` transformed against `operation2` and
     * `operation2` transformed against `operation1`,
     * assuming that `operation1` happended before `operation2` in the total order of
     * operations defined by the server.
     *
     * `transformX` satisfies the following equasion:
     * `transformX(operation1, operation2) ===
     *  [ transform(operation1, operation2, true), transform(operation2, operation1, false) ]`.
     *
     * @param operation1 An operation to transform, which happened earlier in the total order of
     *  operations defined by the server.
     * @param operation2 An operation to transform, which happened later in the total order of
     *  operations defined by the server.
     */
    transformX?(
        operation1: Operation,
        operation2: Operation
    ): [Operation, Operation]

    /**
     * Returns a new operation which can be applied to `baseSnapshot` to obtain `targetSnapshot`.
     *
     * `diff` satisfies the following equasion:
     * `apply(snapshot1, diff(snapshot1, snapshot2, hint)) === snapshot2`
     *
     * @param baseSnapshot The base snapshot.
     * @param targetSnapshot The target snapshot which should be produced by applying the returned
     *  operation to the base snapshot.
     * @param hint A type-specific hint which may be passed to the diff algorithm in order to affect
     *  what operation is returned, in case there is more than one operation which can be applied
     *  to `baseSnapshot` to produce `targetSnapshot`.
     */
    diff?(
        baseSnapshot: Snapshot,
        targetSnapshot: Snapshot,
        hint?: any
    ): Operation

    /**
     * Returns a new operation, which can be applied to `baseSnapshot` to obtain `targetSnapshot`, and
     * an inverted operation. This function may be implemented as an optimization, if both operations
     * can be generated at the same time more efficiently than performing a diff and an invert separately.
     *
     * `diffX` satisfies the following equasion:
     * `diffX(snapshot1, snapshot2, hint) ===
     *   [diff(snapshot1, snapshot2, hint), invert(diff(snapshot1, snapshot2, hint))]`
     *
     * @param baseSnapshot The base snapshot.
     * @param targetSnapshot The target snapshot which should be produced by applying the returned
     *  operation to the base snapshot.
     * @param hint A type-specific hint which may be passed to the diff algorithm in order to affect
     *  what operation is returned, in case there is more than one operation which can be applied
     *  to `baseSnapshot` to produce `targetSnapshot`.
     */
    diffX?(
        baseSnapshot: Snapshot,
        targetSnapshot: Snapshot,
        hint?: any
    ): [Operation, Operation]

    /**
     * Returns a new operation, which subsumes the behaviour of the specified operations.
     *
     * `compose` satisfies the following equasion:
     * `apply(apply(snapshot, operation1), operation2) === apply(snapshot, compose(operation1, operation2))`
     *
     * @param operation1 An earlier operation.
     * @param operation2 A later operation.
     */
    compose?(operation1: Operation, operation2: Operation): Operation

    /**
     * Returns a new operation, which reverts the effect of `operation`.
     *
     * `invert` satisfies the following equasion:
     * `apply(apply(snapshot, operation), invert(operation)) === snapshot`
     *
     * @param operation An operation to invert.
     */
    invert?(operation: Operation): Operation

    /**
     * Determines if `operation` is a no-op.
     * If it returns `true`, the operation is guaranteed to not modify any snapshot when applied.
     * If it returns `false`, the operation is NOT guaranteed to modify all or any snapshots when applied.
     *
     * `isNoop` satisfies the following equasion:
     * `if isNoop(operation) then apply(snapshot, operation) === snapshot`
     *
     * @param operation An operation to check.
     */
    isNoop?(operation: Operation): boolean

    // TODO figure out a better interface or name
    areOperationstSimilar?(
        operation1: Operation,
        operation2: Operation
    ): boolean
}

class TypeManager {
    private types: { [key: string]: Type } = Object.create(null)

    public registerType(type: Type) {
        if (this.types[type.name]) {
            throw new Error(`Duplicate type: ${type.name}`)
        }

        this.types[type.name] = type
    }

    public apply(snapshot: Snapshot, operation: Operation): Result<Snapshot> {
        return this.getType(operation).then(type =>
            type.apply(snapshot, operation)
        )
    }

    public applyX(
        snapshot: Snapshot,
        operation: Operation
    ): Result<[Snapshot, Operation]> {
        return this.getType(operation).then(type => {
            if (type.applyX) {
                return type.applyX(snapshot, operation)
            } else if (type.invert) {
                return [
                    type.apply(snapshot, operation),
                    type.invert(operation)
                ] as [Snapshot, Operation]
            } else {
                return Result.fail(
                    new SyncOtError(
                        ErrorCodes.NotImplemented,
                        `Neither applyX nor invert are implemented in ${
                            operation.type
                        }`
                    )
                )
            }
        })
    }

    public transform(
        operation: Operation,
        anotherOperation: Operation,
        priority: boolean
    ): Result<Operation> {
        return this.getType(priority ? anotherOperation : operation).then(type => {
            if (type.transform) {
                return type.transform(operation, anotherOperation, priority)
            } else if (type.transformX) {
                return priority
                    ? type.transformX(operation, anotherOperation)[0]
                    : type.transformX(anotherOperation, operation)[1]
            } else {
                return operation
            }
        })
    }

    public transformX(
        operation1: Operation,
        operation2: Operation
    ): Result<[Operation, Operation]> {
        return this.getType(operation2).then(type => {
            if (type.transformX) {
                return type.transformX(operation1, operation2)
            } else if (type.transform) {
                return [
                    type.transform(operation1, operation2, true),
                    type.transform(operation2, operation1, false)
                ] as [Operation, Operation]
            } else {
                return [operation1, operation2] as [Operation, Operation]
            }
        })
    }

    public diff(
        baseSnapshot: Snapshot,
        targetSnapshot: Snapshot,
        hint?: any
    ): Result<Operation> {
        return this.getType(targetSnapshot).then(type => {
            if (type.diff) {
                return type.diff(baseSnapshot, targetSnapshot, hint)
            } else if (type.diffX) {
                return type.diffX(baseSnapshot, targetSnapshot, hint)[0]
            } else {
                return Result.fail(
                    new SyncOtError(
                        ErrorCodes.NotImplemented,
                        `Neither diff nor diffX is implemented in ${
                            targetSnapshot.type
                        }`
                    )
                )
            }
        })
    }

    public diffX(
        baseSnapshot: Snapshot,
        targetSnapshot: Snapshot,
        hint?: any
    ): Result<[Operation, Operation]> {
        return this.getType(targetSnapshot).then(type => {
            if (type.diffX) {
                return type.diffX(baseSnapshot, targetSnapshot, hint)
            } else if (type.diff && type.invert) {
                return this.diff(baseSnapshot, targetSnapshot, hint).then(
                    operation =>
                        this.invert(operation).then(invertedOperation =>
                            Result.ok([operation, invertedOperation] as [
                                Operation,
                                Operation
                            ])
                        )
                )
            } else {
                return Result.fail(
                    new SyncOtError(
                        ErrorCodes.NotImplemented,
                        `Neither diffX, nor diff and invert are implemented in ${
                            targetSnapshot.type
                        }`
                    )
                )
            }
        })
    }

    public compose(
        operation: Operation,
        anotherOperation: Operation
    ): Result<Operation> {
        return this.getType(anotherOperation).then(type => {
            if (type.compose) {
                return type.compose(
                    operation,
                    anotherOperation
                )
            } else {
                return Result.fail(
                    new SyncOtError(
                        ErrorCodes.NotImplemented,
                        `compose is not implemented in ${operation.type}`
                    )
                )
            }
        })
    }

    public invert(operation: Operation): Result<Operation> {
        return this.getType(operation).then(type => {
            if (type.invert) {
                return Result.ok(type.invert(operation))
            } else {
                return Result.fail(
                    new SyncOtError(
                        ErrorCodes.NotImplemented,
                        `invert is not implemented in ${operation.type}`
                    )
                )
            }
        })
    }

    public isNoop(operation: Operation): boolean {
        return this.getType(operation)
            .then(type => (type.isNoop ? type.isNoop(operation) : false))
            .catch(_error => false)
            .getValue()
    }

    public areOperationstSimilar(
        operation1: Operation,
        operation2: Operation
    ): boolean {
        return (
            operation1.type === operation2.type &&
            this.getType(operation1)
                .then(
                    type =>
                        type.areOperationstSimilar
                            ? type.areOperationstSimilar(operation1, operation2)
                            : false
                )
                .catch(_error => false)
                .getValue()
        )
    }

    private getType(operationOrSnapshot: Operation | Snapshot): Result<Type> {
        if (!operationOrSnapshot) {
            return Result.fail(new TypeError('Invalid operation or snapshot'))
        }

        const name = operationOrSnapshot.type

        if (typeof name !== 'string') {
            return Result.fail(new TypeError('Invalid operation or snapshot'))
        }

        const type = this.types[name]

        if (!type) {
            return Result.fail(
                new SyncOtError(
                    ErrorCodes.TypeNotFound,
                    `Type not found: ${name}`
                )
            )
        }

        return Result.ok(type)
    }
}

export function createTypeManager() {
    return new TypeManager()
}
