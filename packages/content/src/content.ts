import { Duplex } from 'readable-stream'
import {
    assert,
    createId,
    createInvalidEntityError,
    EmitterInterface,
    SyncOTEmitter,
    validate,
    Validator,
} from '@syncot/util'

/**
 * A globally unique value suitable as an operation's primary key.
 *
 * The format is: `${base64(random-data)}:${userId}`.
 *
 * All `OperationKey`s are generated on the client-side
 * and verified on the server-side. This way each operation has
 * a unique and persistent identity from the moment it is created by the client,
 * which makes it possible to safely submit the same operation multiple times
 * while guarateeing that it will be persisted at most once.
 *
 * The `userId` is included in the `OperationKey` to prevent malicious users from performing
 * key collision attacks targeting other users. There is a tiny non-zero chance that
 * the keys generated by the same user can collide, however, in practice a collision
 * would be likely to happen  only if someone purposefully tried to cause it.
 */
export type OperationKey = string

/**
 * Creates a new OperationKey for the userId.
 */
export function createOperationKey(userId: string): OperationKey {
    assert(typeof userId === 'string', 'Argument "userId" must be a string.')

    return `${createId()}:${userId}`
}

/**
 * Checks if the `key` is a valid `OperationKey`.
 */
export function isOperationKey(key: any): key is OperationKey {
    if (typeof key !== 'string') {
        return false
    }

    const index = key.indexOf(':')
    if (index < 0) {
        return false
    }

    const id = key.slice(0, index)
    return id.length % 4 === 0 && /^[a-zA-Z0-9+/]*=?=?$/.test(id)
}

/**
 * Extracts a user ID from the given operation key.
 * Note that this function performs only basic validation of the key
 * and is **not** a substitute for isOperationKey.
 */
export function getOperationKeyUser(key: OperationKey): string {
    assert(typeof key === 'string', 'Invalid operation key.')
    const index = key.indexOf(':')
    assert(index >= 0, 'Invalid operation key.')
    return key.slice(index + 1)
}

/**
 * The type of metadata which can be attached to content entities.
 */
export interface Meta {
    /**
     * The ID of the user who created the entity.
     */
    user?: string | null
    /**
     * The timestamp at which the entity was created.
     */
    time?: number | null
    /**
     * The ID of the session which the entity was created in.
     */
    session?: string | null
    [key: string]: any
}

/**
 * An operation which can be applied to a document.
 */
export interface Operation {
    /**
     * A globally unique ID of this operation.
     */
    key: OperationKey
    /**
     * The document type.
     */
    type: string
    /**
     * The document ID.
     */
    id: string
    /**
     * The document version created by this operation.
     * It must be an integer between 1 (inclusive) and Number.MAX_SAFE_INTEGER (exclusive).
     */
    version: number
    /**
     * The schema of the content at the version created by this operation.
     */
    schema: string
    /**
     * The action to apply to the document's content at `operation.version - 1` version
     * in order to produce the document's content at `operation.version` version.
     */
    data: any
    /**
     * The operation's metadata.
     */
    meta: Meta | null
}

/**
 * Validates the specified operation.
 * @returns The first encountered error, if found, otherwise undefined.
 */
export const validateOperation: Validator<Operation> = validate([
    (operation) =>
        typeof operation === 'object' && operation != null
            ? undefined
            : createInvalidEntityError('Operation', operation, null),
    (operation) =>
        isOperationKey(operation.key)
            ? undefined
            : createInvalidEntityError('Operation', operation, 'key'),
    (operation) =>
        typeof operation.type === 'string'
            ? undefined
            : createInvalidEntityError('Operation', operation, 'type'),
    (operation) =>
        typeof operation.id === 'string'
            ? undefined
            : createInvalidEntityError('Operation', operation, 'id'),
    (operation) =>
        Number.isInteger(operation.version) &&
        operation.version > 0 &&
        operation.version < Number.MAX_SAFE_INTEGER
            ? undefined
            : createInvalidEntityError('Operation', operation, 'version'),
    (operation) =>
        typeof operation.schema === 'string'
            ? undefined
            : createInvalidEntityError('Operation', operation, 'schema'),
    (operation) =>
        operation.hasOwnProperty('data')
            ? undefined
            : createInvalidEntityError('Operation', operation, 'data'),
    (operation) =>
        typeof operation.meta === 'object'
            ? undefined
            : createInvalidEntityError('Operation', operation, 'meta'),
    (operation) =>
        operation.meta == null ||
        operation.meta.user == null ||
        typeof operation.meta.user === 'string'
            ? undefined
            : createInvalidEntityError('Operation', operation, 'meta.user'),
    (operation) =>
        operation.meta == null ||
        operation.meta.time == null ||
        typeof operation.meta.time === 'number'
            ? undefined
            : createInvalidEntityError('Operation', operation, 'meta.time'),
    (operation) =>
        operation.meta == null ||
        operation.meta.session == null ||
        typeof operation.meta.session === 'string'
            ? undefined
            : createInvalidEntityError('Operation', operation, 'meta.session'),
])

/**
 * A document snapshot at a specific version.
 */
export interface Snapshot {
    /**
     * The document type.
     */
    type: string
    /**
     * The document ID.
     */
    id: string
    /**
     * The document version which the snapshot represents.
     * It must be an integer between 0 (inclusive) and Number.MAX_SAFE_INTEGER (exclusive).
     */
    version: number
    /**
     * The schema of the document's content at the snapshot's version.
     */
    schema: string
    /**
     * The document's content at the snapshot's version.
     */
    data: any
    /**
     * The snapshot's metadata.
     */
    meta: Meta | null
}

/**
 * The names of the requests supported by the content service.
 */
export const requestNames = new Set([
    'getSnapshot',
    'submitOperation',
    'streamOperations',
])

/**
 * Events emitted by `ContentService`.
 */
export interface ContentServiceEvents {
    error: Error
}

/**
 * Events emitted by `ContentClient`.
 */
export interface ContentClientEvents {
    error: Error
    active: void
    inactive: void
}

/**
 * The base interface for `ContentService` and `ContentClient`.
 */
export interface ContentBase {
    /**
     * Gets a snapshot of a document at a given version.
     *
     * @param type The document type.
     * @param id The document ID.
     * @param version The document version. Defaults to the latest version.
     * @returns A snapshot matching the params.
     */
    getSnapshot(
        type: string,
        id: string,
        version?: number | null | undefined,
    ): Promise<Snapshot>

    /**
     * Submits the operation to update a document.
     *
     * The `data` and `version` properties may be updated before the operation is recorded,
     * if the operation is rebased internally on top of other operation recorded earlier.
     * The `meta.time` property is always updated to the server time at which the operation
     * is recorded.
     * The `meta.user` property is always updated to match the ID of the user who sumbitted
     * the operation.
     *
     * @param operation The operation to submit.
     */
    submitOperation(operation: Operation): Promise<void>

    /**
     * Streams the specified operations.
     * @param type The document type.
     * @param id The document ID.
     * @param versionStart The version number of first operation to include. Defaults to 0.
     * @param versionEnd The version number of the first operation to exclude. Defaults to Number.MAX_SAFE_INTEGER.
     * @returns A stream of Operation objects.
     */
    streamOperations(
        type: string,
        id: string,
        versionStart?: number | null | undefined,
        versionEnd?: number | null | undefined,
    ): Promise<Duplex>
}

/**
 * The `ContentService` interface.
 */
export interface ContentService
    extends ContentBase,
        EmitterInterface<SyncOTEmitter<ContentServiceEvents>> {}

/**
 * The `ContentClient` interface.
 */
export interface ContentClient
    extends ContentBase,
        EmitterInterface<SyncOTEmitter<ContentClientEvents>> {
    /**
     * Indicates if the ContentClient is able to communicate with the ContentService.
     */
    readonly active: boolean
    /**
     * The read-only `sessionId` from the AuthClient, exposed here for convenience.
     * It is `undefined` if, and only if, `active` is `false`.
     */
    readonly sessionId: string | undefined
    /**
     * The read-only `userId` from the AuthClient, exposed here for convenience.
     * It is `undefined` if, and only if, `active` is `false`.
     */
    readonly userId: string | undefined
}
