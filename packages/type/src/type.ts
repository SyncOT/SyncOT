import { createInvalidEntityError } from '@syncot/error'
import { throwError, validate, Validator } from '@syncot/util'

/**
 * Represents the actions which turn one snapshot into another.
 * New `Operation`s can be created from scratch or
 * generated in various ways from existing `Operation`s and `Snapshot`s.
 */
export interface Operation {
    readonly data: any
    readonly documentId: string
    readonly documentType: string
    readonly kind: 'Operation'
    readonly meta: any
    readonly sequence: number
    readonly sessionId: string
    readonly version: number
}

/**
 * Represents the state of a document at a particular version.
 * New `Snapshot`s can be created from scratch, using `Type#create` or
 * generated by applying `Operation`s to existing `Snapshot`s.
 */
export interface Snapshot {
    readonly data: any
    readonly documentId: string
    readonly documentType: string
    readonly kind: 'Snapshot'
    readonly meta: any
    readonly sequence: number
    readonly sessionId: string
    readonly version: number
}

type ValidatorFactory = <
    EN extends 'Operation' | 'Snapshot',
    T extends Operation | Snapshot = EN extends 'Operation'
        ? Operation
        : EN extends 'Snapshot'
        ? Snapshot
        : never
>(
    entityName: EN,
) => Validator<T>

const validateSelf: ValidatorFactory = entityName => self =>
    self != null && typeof self === 'object'
        ? undefined
        : createInvalidEntityError(entityName, self, null)

const validateKind: (
    kind: string,
) => ValidatorFactory = kind => entityName => self =>
    self.kind !== kind
        ? createInvalidEntityError(entityName, self, 'kind')
        : undefined

const validateDocumentId: ValidatorFactory = entityName => self =>
    typeof self.documentId === 'string'
        ? undefined
        : createInvalidEntityError(entityName, self, 'documentId')

const validateDocumentType: ValidatorFactory = entityName => self =>
    typeof self.documentType !== 'string'
        ? createInvalidEntityError(entityName, self, 'documentType')
        : undefined

const validateVersion: (
    minVersion: number,
) => ValidatorFactory = minVersion => entityName => self =>
    !Number.isSafeInteger(self.version) || self.version < minVersion
        ? createInvalidEntityError(entityName, self, 'version')
        : undefined

const validateSessionId: ValidatorFactory = entityName => self =>
    typeof self.sessionId === 'string'
        ? undefined
        : createInvalidEntityError(entityName, self, 'sessionId')

const validateSequence: ValidatorFactory = entityName => self =>
    !Number.isSafeInteger(self.sequence) || self.sequence < 0
        ? createInvalidEntityError(entityName, self, 'sequence')
        : undefined

const validateExists: (
    property: 'data' | 'meta',
) => ValidatorFactory = property => entityName => self =>
    self.hasOwnProperty(property)
        ? undefined
        : createInvalidEntityError(entityName, self, property)

export const validateOperation: Validator<Operation> = validate(
    [
        validateSelf,
        validateExists('data'),
        validateDocumentId,
        validateKind('Operation'),
        validateExists('meta'),
        validateSequence,
        validateSessionId,
        validateDocumentType,
        validateVersion(1),
    ].map(validator => validator('Operation')),
)
export const assertOperation = (operation: Operation) =>
    throwError(validateOperation(operation))

export const validateSnapshot: Validator<Snapshot> = validate(
    [
        validateSelf,
        validateExists('data'),
        validateDocumentId,
        validateKind('Snapshot'),
        validateExists('meta'),
        validateSequence,
        validateSessionId,
        validateDocumentType,
        validateVersion(0),
    ].map(validator => validator('Snapshot')),
)
export const assertSnapshot = (snapshot: Snapshot) =>
    throwError(validateSnapshot(snapshot))

/**
 * Defines an [OT](https://en.wikipedia.org/wiki/Operational_transformation) or
 * a [CRDT](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) data type.
 *
 * Each type must define `name`, `create` and `apply`.
 * OT types must additionally implement `transform` or `transformX`.
 * `diff`, `compose` and `invert` may be implemented to enable some optional features.
 *
 * All type functions must be "pure":
 *
 * - have no side effects AND
 * - always produce identical results given identical arguments.
 */
export interface Type {
    /**
     * The type's name.
     */
    readonly name: string

    /**
     * Creates an initial "empty" snapshot with the specified `id`.
     */
    create(id: string): Snapshot

    /**
     * Returns a new snapshot, which is the result of applying `operation` to `snapshot`.
     *
     * @param snapshot A snapshot.
     * @param operation An operation to apply to the snapshot.
     */
    apply(snapshot: Snapshot, operation: Operation): Snapshot

    /**
     * Returns a new operation, which subsumes the behaviour of `operation`, but modified in such a way
     * that it can be applied to a snapshot modified by `anotherOperation.
     *
     * The purpose of transformation is to allow applying `operation` to a snapshot modified
     * by `anotherOperation`. This way each client can apply operations in any order and obtain an
     * identical final snapshot, as long as the operations are properly transformed.
     *
     * Although each client can apply operations in any order, SyncOT uses a central server which
     * defines a canonical total order of operations. The `priority` parameter indicates which operation
     * happened first in that cannonical total order.
     *
     * `transform` satisfies the following equasion:
     * `apply(apply(snapshot, operation1), transform(operation2, operation1, false)) ===
     *      apply(apply(snapshot, operation2), transform(operation1, operation2, true))`
     *
     * @param operation An operation which needs to be transformed, so that it can be
     *  applied to the snapshot modified by `anotherOperation.
     * @param anotherOperation An operation which has modified the snapshot to which
     *  `operation` needs to be applied.
     * @param priority If `true`, `operation` happened first in the total order of operations
     *  defined by the server, otherwise `anotherOperation` happended first.
     */
    transform?(
        operation: Operation,
        anotherOperation: Operation,
        priority: boolean,
    ): Operation

    /**
     * Returns `operation1` transformed against `operation2` and
     * `operation2` transformed against `operation1`,
     * assuming that `operation1` happended before `operation2` in the total order of
     * operations defined by the server.
     *
     * `transformX` satisfies the following equasion:
     * `transformX(operation1, operation2) ===
     *  [ transform(operation1, operation2, true), transform(operation2, operation1, false) ]`.
     *
     * @param operation1 An operation to transform, which happened earlier in the total order of
     *  operations defined by the server.
     * @param operation2 An operation to transform, which happened later in the total order of
     *  operations defined by the server.
     */
    transformX?(
        operation1: Operation,
        operation2: Operation,
    ): [Operation, Operation]

    /**
     * Returns a new operation which can be applied to `baseSnapshot` to obtain `targetSnapshot`.
     *
     * `diff` satisfies the following equasion:
     * `apply(snapshot1, diff(snapshot1, snapshot2, hint)) === snapshot2`
     *
     * @param baseSnapshot The base snapshot.
     * @param targetSnapshot The target snapshot which should be produced by applying the returned
     *  operation to the base snapshot.
     * @param hint A type-specific hint which may be passed to the diff algorithm in order to affect
     *  what operation is returned, in case there is more than one operation which can be applied
     *  to `baseSnapshot` to produce `targetSnapshot`.
     */
    diff?(
        baseSnapshot: Snapshot,
        targetSnapshot: Snapshot,
        hint?: any,
    ): Operation

    /**
     * Returns a new operation, which subsumes the behaviour of the specified operations.
     *
     * `compose` satisfies the following equasion:
     * `apply(apply(snapshot, operation1), operation2) === apply(snapshot, compose(operation1, operation2))`
     *
     * @param operation1 An earlier operation.
     * @param operation2 A later operation.
     */
    compose?(operation1: Operation, operation2: Operation): Operation

    /**
     * Returns a new operation, which reverts the effect of `operation`.
     *
     * `invert` satisfies the following equasion:
     * `apply(apply(snapshot, operation), invert(operation)) === snapshot`
     *
     * @param operation An operation to invert.
     */
    invert?(operation: Operation): Operation
}
